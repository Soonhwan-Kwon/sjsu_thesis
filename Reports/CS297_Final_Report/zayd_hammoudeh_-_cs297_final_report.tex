\documentclass{report}

\usepackage{url}
\usepackage{indentfirst}
\usepackage{float}

\usepackage[T1]{fontenc}
\usepackage{textcomp} % Required for upquote.
\usepackage{listings} % Include the listings-package
% Ensure quotes in listings are straight.
% Cleaner way to print strings in listings packages so no space symbol.
\lstset{showstringspaces=false, 
        upquote=true} 


\usepackage{mdframed}
\usepackage[numbers,sort]{natbib}
%\usepackage[english]{babel} % Need for text wrap in table.
\usepackage{array} % Needed for centering in the table
\usepackage[export]{adjustbox} % loads also graphicx
\usepackage{graphicx}

\usepackage{hyperref} % Creates links in the PDF document.
\hypersetup{hidelinks} % Do not include boxes around links

% Defines the table of contents depth and the subsection numbering depth
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\title{An Enhanced Jigsaw Puzzle Solver \\[1in]
	   CS297 Final Report}

\author{
  Zayd Hammoudeh \\
  (zayd.hammoudeh@sjsu.edu)
  }


\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}

% Skip lines after each paragraph.
\setlength\parskip{\baselineskip}

\begin{document}

\maketitle

\pagenumbering{roman}

\tableofcontents{\protect\newpage}

\addcontentsline{toc}{section}{List of Figures}
\listoffigures
\newpage
 
\pagenumbering{arabic}

\renewcommand\thesection{\arabic{section}}

\section{Introduction}\label{sec:introduction}

Jigsaw puzzles have been around since the 1760s when they were made from wood.  Their name derives from the fact that they were originally carved using jigsaws.   The 1930s saw the introduction of the modern jigsaw puzzle where an image was printed on a cardboard sheet that was cut into a set of interlocking pieces.  Although jigsaw puzzles had been solved by children for centuries, it was not until 1964 that the first automated jigsaw puzzle solver was proposed by \cite{freeman1964}, and that solver could only solve 9 piece puzzles.  While an automated jigsaw puzzle solver may seem trivial, it has been shown by \cite{altman1990} and \cite{demaine2007} to be strongly NP-complete when pairwise compatibility between pieces is not a reliable metric for determining adjacency.

Jig swap puzzles are specific type of jigsaw puzzle where rather than pieces have different (usually unique) shaped, each piece is a square of equal size.  Jig swap puzzles are substantially more difficult to solve than standard jigsaw puzzle as one can no longer consider mechanical compatibility when trying to determine a relationship between pieces.  In such scenarios, one can only on the individual piece's image information when solving the possible.  

Solving a jigsaw puzzle simplifies to reconstructing an object from a set of component pieces.  As such, techniques developed for jigsaw puzzles can be generalized to many practical problems.  Examples where jigsaw puzzle strategies have been used include: reassembly of archaeological artifacts \cite{brown2008} \cite{koller2006}, digital forensic analysis of deleted files \cite{garfinkel2010}, image editing \cite{cho2008}, 

Currently, there is no full implementation of Haskell in the JVM.  One Haskell dialect that is runnable in Java is Frege \cite{frege}.  

This project implements, \emph{HamSkill}, which is a transpiler from Haskell to Scala; \textit{HamSkill} enables a dialect of Haskell to run in the JVM.  

\section{Key Project Requirements}\label{sec:keyProjectRequirements}

When designing and implementing this project, there were four primary goals:

\begin{enumerate}

\item \textbf{Runnable in the Java Virtual Machine} - As explained in Section~\ref{sec:jvm}, Java's Virtual Machine enables significant machine independence, which Haskell does not currently have.

\item \textbf{Minimal JVM Requirements} - In addition to just running in the JVM, \textit{HamSkill} was created to be as standalone as possible.  As an example, it was not expected that in most applications, the user would have Scala installed on their machine.  To achieve this maximum portability, some more niche features of Haskell may not be supported.

\item \textbf{Identical Input and Output Between Haskell and \emph{HamSkill}} - In many scenarios, it may not be sufficient for a Haskell program to simply run inside the JVM.  Rather, it is more likely that the output generated by the two environments will need to be identical.  As such, \emph{HamSkill} includes an additional post-processing step to ensure its output is identical to that of Haskell.

\item \textbf{Human Readable Output Code} - A transpiler is any program that takes source code from one programming language and outputs code in another programming language, with a similar level of abstraction \cite{jansen_2015}.  To enable increased reuse of the outputted code, \textit{HamSkill} uses techniques such as indenting, newlines, etc. to maximize the readability of the generated output.  While this is not a necessary requirement for the complete system to work properly, it enhances the tool's potential.

\end{enumerate}

\section{\textit{HamSkill}'s Software Architecture}\label{sec:hamskillSoftwareArchitecture}

\emph{HamSkill} is a transpiler that takes Haskell code as an input, converts it to Scala, and then runs the transpiled code in the JVM.  The \emph{HamSkill} implementation consists of six major components.  They are:

\begin{itemize}
   \item ANTLR Lexer and Parser
   \item \texttt{Haskell} ANTLR Grammar
   \item \texttt{ScalaOutput} ANTLR Grammar
   \item Scala Runtime Environment
   \item \texttt{HamskillMain} Java Class
   \item \texttt{ScalaOutput} Java Class
\end{itemize}

\

\pagebreak
\bibliographystyle{plainurl}
\bibliography{cs297_final_report_biblio}

\end{document}
