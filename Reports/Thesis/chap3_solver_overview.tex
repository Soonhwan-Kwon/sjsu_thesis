\chapter{Mixed-Bag Solver Overview}

This thesis' Mixed-Bag Solver supports Type~1, Type~2, and Mixed-Bag Puzzles.  It consists of five distinct stages namely: segmentation, stitching, hierarchical clustering of segments, seed piece selection, and final assembly.  The flow of the algorithm is shown in Figure~\ref{fig:multipuzzleSolverArchitecture}; the pseudocode for the solver, including the input(s) and output of each stage is shown in Algorithm~\ref{alg:mixedBagSolver}.

The following subsections describe each of Mixed Bag Solver's stages/subfunctions.  It also discusses the assembler, which is a separate but associated component of the architecture.

\begin{figure}[ht!]
	\centering
		\includegraphics[width=1.0\textwidth]{images/cropped_algorithm_structure_overview.pdf}
	\caption{Components of the Mixed-Bag Puzzle Solver}\label{fig:multipuzzleSolverArchitecture}
\end{figure}

\begin{algorithm}
\caption{Pseudocode for the Mixed Bag Solver}\label{alg:mixedBagSolver}
\begin{algorithmic}[1]
\Function{MixedBagSolver}{$all\_pieces$}
    \State $solved\_segments \gets \textproc{Segmentation}\text{(} all\_pieces \text{)}$
	\State $overlap\_matrix \gets \textproc{Stitching}\text{(} solved\_segments \text{, } all\_pieces \text{)}$
	\State $segment\_clusters \gets \textproc{PerformHierarchicalClustering} \text{(} solved\_segments \text{, } overlap\_matrix \text{)}$
	\State $puzzle\_start\_pieces \gets \textproc{FindStartingPieces} \text{(} segment_clusters \text{)}$
	\State $solved\_puzzles \gets \textproc{RunFinalAssembly} \text{(} puzzle\_start\_pieces \text{, } all\_pieces \text{)}$
    \State \Return $solved\_puzzles$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Assembler}\label{sec:SolverAssembler}

The assembler assigns the placement (and optionally rotation) of the puzzle pieces in the solved puzzle.  This solver architecture is largely independent of the particular assembler used.  Hence, any improvements or modifications to the assembler can be directly incorporated into the Mixed-Bag Solver to improve its performance.  What is more, if a particular solver performs better than another for a particular application, the solvers can be interchanged.  This provides the Mixed-Bag Solver with significant flexibility and upgradability to maximize performance across a wide range of applications.

For all experiments in this thesis, we used the solver proposed by Paikin \& Tal \cite{paikin2015}.  It was selected because it the current state-of-the-art.  What is more, since it supports mixed bag puzzles, it can be used for direct comparison of performance.

\section{Segmentation}\label{sec:Segmentation}

As shown in Algorithm~\ref{}, segmentation takes as input only the bag of puzzle pieces created from the original images; unlike all other solvers to date, this algorithm takes no other inputs.  The role of stage is to provide structure to the unordered input.  This is done by partitioning the pieces into disjoint sets, referred to here as segments.  These segments are groups of puzzle pieces where there is a high degree of confidence that the pieces are assembled correctly.

Algorithm~\ref{alg:segmentation} outlines the basic segmentation framework.  The algorithm is iterative and will have one or more rounds.  In each round, all pieces that have not yet been assigned to a segment are assembled as if they all belong to a single ground truth image.  This is done as it eliminates the need to make any assumptions regarding the input at this early stage of the solver.  While it may lead to a single puzzle being divided into multiple segments, these segments can be merged together later in a later stage of the solver.

After the single puzzle is assembled in each round, the solved puzzle is then divided into segments; the procedure for this is described in Section~\label{sec:segmentPuzzle}.  Assuming the largest segment exceeds the minimum allowed size\footnote{For this thesis, it was observed that a minimum segment size of 7 provided the best balance between solution quality and algorithm execution time.}, it is passed to the next stage of the Mixed-Bag Solver.  

The term ``\textit{$\alpha$}'' in Algorithm~\ref{alg:segmentation} defines which segments other than the largest one constructed puzzle are immediately passed to the next solver stage.  In this thesis, \textit{$\alpha$} was set to 0.5, meaning any segment that was at least half the size of the largest segment in that round (and larger than the minimum segment size) is saved.  This scalar value provides sufficient balance between ensuring the largest segments for analysis with limiting the execution time of this stage.

Once a piece is assigned to a saved segment, it is removed from the set of unassigned pieces.  Hence, those pieces will not be placed in the next segmentation round.  Segmentation continues until all pieces have been assigned to sufficiently large segments, or no segment exceeds the minimum allowed segment size.

\begin{algorithm}
\caption{Pseudocode for the Segmentation Algorithm}\label{alg:segmentation}
\begin{algorithmic}[1]
\Function{Segmentation}{$all\_pieces$}
    \State $\textit{solved\_segments} \gets \{ \}$
    \State $unassigned\_pieces \gets \{ \textit{all\_pieces} \}$
    \Repeat
        \State $solved\_puzzle \gets \textbf{run\_single\_puzzle\_assembly}(unassigned\_pieces)$
        \State $puzzle\_segments \gets \textbf{segment}(solved\_puzzle\text)$
        \State $max\_segment\_size \gets \text{maximum size of segment in } solved\_segments$
        \ForEach{$segment \in puzzle\_segments$}
            \If{$|segment| \text{ > } \alpha \times max\_segment\_size$}
                \State $\text{add } segment \text{ to } solved\_segments$
                \State $\text{remove pieces in } segment \text{ from } unassigned\_pieces$
            \EndIf
        \EndFor
    \Until{$max\_segment\_size \text{ < } smallest\_allowed \textbf{ or } |unplaced\_pieces| \text{ < } 0$}
    \State \Return $solved\_segments$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{The segment Function}\label{sec:segmentPuzzle}

The \texttt{segment} function shown in Algorithm~\ref{alg:segmentPuzzle} is adapted from the kernel growing segmentation procedure modified by Pomeranz \textit{et al.}, where it was shown to have greater than 99.7\% accuracy identifying genuine neighbors \cite{pomeranz2011}. The kernel of each segment is a single seed piece.

\begin{algorithm}
\caption{Pseudocode for the segment Function}\label{alg:segmentPuzzle}
\begin{algorithmic}[1]
\Function{segment}{$solved\_puzzle$}
    \State $\textit{puzzle\_segments} \gets \{ \}$
    \State $\textit{unassigned\_pieces} \gets \{ \text{all pieces in } \textit{solved\_puzzle} \}$
\item[]
    \While{$|\textit{unassigned\_pieces}| \text{ > } 0$}
        \State $\textit{segment} \gets \text{ new empty segment}$
        \State $\textit{seed\_piece} \gets \text{next piece in } \textit{unassigned\_pieces}$
        \State $\textit{queue} \gets [\textit{seed\_piece}]$
\item[]
        \While{$|\textit{queue}| \text{ > } 0$}
            \State $\textit{piece} \gets \text{next piece in }\textit{queue}$
            \State $\text{add } \textit{piece} \text{ to } \textit{segment}$
\item[]
            \ForEach{$\textit{neighbor\_piece} \text{ of } \textit{piece}$}
            	\If{$\textbf{is\_best\_buddies}(\textit{neighbor\_piece}, \textit{piece})$}
            		\State $\text{add } \textit{neighbor\_piece} \text{ to } \textit{queue}$
            		\State $\text{remove } \textit{neighbor\_piece} \text{ from } \textit{unassigned\_pieces}$
            	\EndIf
            \EndFor
        \EndWhile
\item[]
        \State $\textit{articulation\_points} \gets \textbf{find\_articulation\_points}(\textit{segment})$
        \State $\text{remove } \textit{articulation\_points} \text{ from } \textit{segment}$
\item[]
		\State $\textit{disconnected\_pieces} \gets \textbf{find\_disconnected\_pieces}(\textit{segment},\textit{seed\_piece})$        
        \State $\text{add } \textit{segment} \text{ to } \textit{puzzle\_segments}$
\item[]
		\State $\text{remove } \textit{disconnected\_points} \text{ from } \textit{segment}$
        \State $\text{add } \textit{articulation\_points} \text{ and } \textit{disconnected\_pieces} \text{ to } \textit{unassigned\_pieces}$
    \EndWhile
\item[]
    \State \Return $\textit{puzzle\_segments}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Whenever a piece is added to a segment, it is removed from the set of unassigned pieces. What is more, the algorithm check's all pieces directly adjacent to the added piece.  If the adjacent piece and the added piece are ``best buddies'' (i.e., each is more similar to the other on their respective sides than they are to any other piece as defined by \cite{pomeranz2011} and \cite{paikin2015}), then the adjacent piece is also added to the segment.  This process continues until no there are no pieces adjacent to a segment member that fulfill the best buddy criteria.

If Pomeranz \textit{et al.}'s original segmentation algorithm is used for Mixed-Bag puzzles, two correctly assembled segments from different input puzzles can be merged into a single segment.  This is usually in the form of narrow bridges no wider than a single piece. This necessitates that each segment goes through post-processing to identify and remove these single point bridges; the procedure for doing this is described in Section~\ref{sec:ArticulationPoints}.  

Once these single piece bridges have been broken, one or more pieces become disconnected from the segment.  These pieces are then returned to the set of unassigned pieces to be assigned to a different segment.  At the end of segment, each piece in the puzzle will be assigned to exactly one segment.

\subsection{Articulation Points}\label{sec:ArticulationPoints}

A segment can be model as a single connected graph, with the vertices being the puzzle pieces and the edges being the best buddy relationships.  An articulation point is any vertex (i.e., puzzle piece) whose removal increases the number of connected components.  The Mixed-Bag Solver uses the algorithm proposed by \ref{cormenIntroToAlgorithms} for identifying articulation points.  While most implementations of this algorithm are recursive, this thesis instead uses an iterative approach as segment can be several thousand pieces in sizes.  As such, a recursive implementation is prone to stack overflows.

\section{Stiching}\label{sec:stitchingPieceSolving}

As defined previously, a segment represents a partial assembly where there is a particularly high degree of confidence that the placement is correct. During the segmentation stage, puzzle pieces from a single ground truth image segment may be partitioned into multiple segments. If two segments are similar, it is likely that if one segment is allowed to grow that it would eventually merge with its adjacent segment.  However, uncontrolled segment expansion can cause a segment to grow beyond the boundaries of its ground truth image and merge with a segment from a different input image.  This thesis controls segmentation growth through the use of multiple ``mini solvers,'' which each have a ``stitching piece'' as their seed.  The output from these mini solvers are used to determine inter-segment similarity as described in the following subsection.

\subsection{Definition of a Stitching Piece}

As the name indicates, the set of stitching pieces assist in the ``stitching'' together of associated segments.  Since segments are disjoint, a segment will need to grow in order to join with another segment.  

\subsection{defi}



An ``open location'' with respect to a segment is any puzzle location that is not populated with a member of that segment.  

\subsection{Determine the }

Stitching pieces should be near the edge of a segment to increase the likelihood of growth towards a neighboring segment.  However,  if a stitching piece is too close to the edge of the segment, the algorithm may make erroneous segmentation associations.   

As outlined in Algorithm~\ref{alg:stitchingPieceDistance}, the Mixed-Bag Solver uses iterative boundary tracing to determine each stitching piece's distance to the nearest puzzle location that is not populated with a piece that is a member of the stitching piece's segment..

The algorithm begins by finding set of puzzle locations adjacent to pieces in the segment that are not filled by segment members.  These locations represent the .

\begin{algorithm}
\caption{Pseudocode for Determining a Segment Point's Manhattan Distance to the Nearest Open Location}\label{alg:findDistanceToOpen}
\begin{algorithmic}[1]
\Procedure{FindPieceDistanceToOpen}{$segment\_pieces$}
    \State $\textit{explored\_pieces} \gets \{ \}$
    \State $\textit{locations\_at\_prev\_dist} \gets \{ \textit{segment\_pieces} \}$
    \State $\textit{distance\_to\_open} \gets 1$
\item[]
    \While{$|\textit{explored\_pieces}| \text{ > } 0$}
        \State $\textit{locations\_at\_current\_dist} \gets \{ \}$
\item[]
        \ForEach{$\textit{prev\_dist\_loc} \in \textit{locations\_at\_prev\_dist}$}
        	\ForEach{$\textit{adjacent\_loc} \textbf{ of } \textit{prev\_dist\_loc}$}
        		\If{$\exists \text{ } \textit{piece} \text{ at }\textit{adjacent\_loc} \textbf{ and } \textit{piece} \notin \textit{explored\_pieces}$}
        		
        			\State $\text{set } \textit{distance\_to\_open} \text{ for } \textit{piece}$
        			\State $\text{remove } \textit{piece} \text{ from } \textit{explored\_pieces}$
        			\State $\text{add } \textit{adjacent\_loc} \text{ to } \textit{locations\_at\_current\_dist}$
        		\EndIf
        	\EndFor
        \EndFor
\item[]
    \State $\textit{locations\_at\_prev\_dist} \gets locations\_at\_current\_dist$
    \State $\textit{distance\_to\_open} \gets \textit{distance\_to\_open} + 1$
    \EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

Algorithm~\ref{alg:findDistanceToOpen} is run for each of the segments.  A single iteration of the algorithm has time complexity of $O(n)$, where $n$ is the number of pieces in the segment.  What is more, the algorithm is robust enough to handle voids within a segment as well as potential necking within the segment where two large segment components are joined by a narrower bridge.

\subsection{Stitching Pieces}

If stitching pieces are placed to close together, the solver will perform many redundant solvings.  While this may not have a deleterious effect on the solver output, it can significantly increase the execution time of this stage.  In contrast, if stitching pieces are placed too far apart, subtle segment pairings may be missed.  To achieve 

Figure~\ref{} shows an original image along with an segment found during the segmentation.  This figure also shows the location of the stitching pieces (denoted with a white cross).  

\subsection{Quantifying Inter-Segment Similarity}



\section{Hierarchical Clustering of Segments}

Agglomerative hierarchical clustering is a bottom-up clustering algorithm where in each clustering round, two clusters are merged.  Algorithm~\ref{alg:hierarchicalClustering} shows the basic flow of the hierarchical clustering algorithm of the Mixed-Bag Solver; it is adapted from \cite{tanIntroToDataMining}.  

The only inputs to the hierarchical clustering algorithm are the segments found in the segmentation stage and the Segment Overlap Matrix from the Stitching stage.

\begin{algorithm}
\caption{Pseudocode for the Hierarchical Clustering Algorithm}\label{alg:hierarchicalClustering}
\begin{algorithmic}[1]
\Function{PerformHierarchicalClustering}{$solved\_segments, overlap\_matrix$}
	\State $\textit{segment\_clusters} = \{ \}$	
	\ForEach{$segment_i \in \textit{solved\_segments}$}
		\State $\text{add new segment cluster } \Phi_i \text{ containing } segment_i \text{ to } \textit{segment\_clusters}$
	\EndFor
    \State $\text{Compute the similarity matrix, } \Gamma$
\item[]
    \While{$\text{maximum similarity in } \Gamma \text{ > } \textit{min\_cluster\_similarity}$}
    	\State $\text{Merge the two most similar clusters } \Phi_i \text{ and } \Phi_j \text{ in } \textit{segment\_clusters}$
    	\State $\text{Update the similarity matrix, } \Gamma \text{ for the merged clusters}$
	\EndWhile
\item[]
    \State \Return $\textit{cluster\_segments}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Calculating the Initial Similarity Matrix}

The Segment Overlap Matrix is a form of hollow matrix, where all elements in the matrix, except those along the diagonal, are populated with meaningful values.  In contrast, hierarchical clustering merges segments using a triangular, similarity matrix.  Equation~\eref{eq:segmentSimilarity} defines the similarity, $\omega_(i,j)$ between any two clusters $\Phi_i$ to $\Phi_j$.

\begin{equation} \label{eq:segmentSimilarity}
\omega_{i,j} = \frac{Overlap(\Phi_i, \Phi_j) + Overlap(\Phi_j, \Phi_i)}{2} 
\end{equation}

If there are $n$ solved segments found during segmentation, then the initial similarity matrix $\Gamma$ is size $n$ by $n$.  Each element in $\Gamma$ is defined by Equation~\eref{eq:similarityMatrix}.  Both $i$ and $j$ are bounded between $1$ and $n$ inclusive.  What is more, all elements in $\Gamma$ are normalized between 0 and 1, also inclusive.

\begin{equation} \label{eq:similarityMatrix}
\Gamma = \begin{cases} 
	0 & j >= i
\\
	\omega_{i,j} & i < j
\end{cases} 
\end{equation}

\subsection{Updating the Similarity Matrix via Single Linking}

The Mixed-Bag Solver uses the Single Link version of hierarchical clustering.  Hence, the similarity between any two cluster segments is defined as the similarity between the two most similar segments in either cluster.  This approach is required because two segments clusters may only be adjacent along the border of two of the composite segments.  

Equation~\eref{eq:segmentClusterMerge} defines the similarity between any a merged cluster containing segment clusters, $\Psi_x$ and $\Psi_y$, and any other segment cluster $\Psi_z$.  Note that segment $\Phi_i$ is a member of the union of $\Psi_x$ and $Psi_y$ while segment $\Phi_j$ is a member of segment cluster $\Psi_z$.

\begin{equation} \label{eq:segmentClusterMerge}
	\omega_{x \cup y,z} = \argmax_{\Phi_i \in \Psi_x \cup \Psi_y} \bigg( \argmax_{\Phi_j \in \Psi_z} \omega_{i,j} \bigg) 
\end{equation}

\subsection{Terminating Hierarchical Clustering}

Unlike traditional hierarchical clustering, the Mixed-Bag Solver does not always merge all segment clusters  until only a cluster remains. Instead clustering continues until the similarity between any of the remaining clusters drops below a predefined threshold.  In this thesis, a minimum similarity of $0.1$ provided sufficient clustering accuracy without merging unrelated segments.

\section{Selecting Seed Pieces}

\section{Final Assembly}